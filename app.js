// This question is asked by Microsoft. Given a string, return the index of its first unique character. If a unique character does not exist, return -1.

// Ex: Given the following strings...

// "abcabd", return 2
// "thedailybyte", return 1
// "developer", return 0

function firstUniqueCharater(str) {
  let map1 = {};
  const str1 = str.split(",").join();
  for (let a of str1) {
    map1[a] = map1[a] ? map1[a] + 1 : 1;
  }
  console.log(map1);
  for (let a in map1) {
    // console.log(map1[a]);
    if (map1[a] == 1) {
      return str.indexOf(a);
    }
  }
}
console.log(firstUniqueCharater("abcabd"));

// This question is asked by Google. You are given two strings, s and t which only consist of lowercase letters. t is generated by shuffling the letters in s as well as potentially adding an additional random character. Return the letter that was randomly added to t if it exists, otherwise, return ’  ‘.
// Note: You may assume that at most one additional character can be added to t.

// Ex: Given the following strings...

// s = "foobar", t = "barfoot", return 't'
// s = "ide", t = "idea", return 'a'
// s = "coding", t "ingcod", return ''

// This question is asked by Google. Given two integer arrays, return their intersection.
// Note: the intersection is the set of elements that are common to both arrays.

// Ex: Given the following arrays...

// nums1 = [2, 4, 4, 2], nums2 = [2, 4], return [2, 4]
// nums1 = [1, 2, 3, 3], nums2 = [3, 3], return [3]
// nums1 = [2, 4, 6, 8], nums2 = [1, 3, 5, 7], return []

// function intersectionNumbers(arr) {
//   let map1 = {};
//   const arr1 = [];
//   for (let a of arr) {
//     map1[a] = map1[a] ? map1[a] + 1 : 1;
//     if (map1[a] > 1) arr1.push(a);
//   }
//   return arr1;
// }
// console.log(intersectionNumbers([2, 4, , 2, 4, 8, 8]));

// This question is asked by Amazon. Given two strings representing sentences, return the words that are not common to both
// strings (i.e. the words that only appear in one of the sentences).
// You may assume that each sentence is a sequence of words (without punctuation) correctly separated using space characters.
// Ex: given the following strings...

// sentence1 = "the quick", sentence2 = "brown fox", return ["the", "quick", "brown", "fox"]
// sentence1 = "the tortoise beat the haire", sentence2 = "the tortoise lost to the haire", return ["beat", "to", "lost"]
// sentence1 = "copper coffee pot", sentence2 = "hot coffee pot", return ["copper", "hot"]

function twoStrings(str1, str2) {
  const str11 = str1.split(" ");
  let arr1 = [];
  console.log(str11);
  const str22 = str2.split(" ");
  console.log(str22);
  console.log(JSON.stringify(str11) === JSON.stringify(str22));
  if (JSON.stringify(str11) === JSON.stringify(str22)) return str11;
  let map1 = {};
  let str33 = [];
  str33 = str11.concat(str22);
  console.log("str33", str33);
  for (let g of str33) {
    map1[g] = map1[g] ? map1[g] + 1 : 1;
  }
  for (let x in map1) {
    if (map1[x] == 1) arr1.push(x);
  }
  console.log(map1);
  return arr1;
}
console.log(
  "result",
  twoStrings("the tortoise beat the haire", "the tortoise lost to the haire")
);
console.log("result", twoStrings("the quick", "brown fox"));
console.log("result", twoStrings("copper coffee pot", "hot coffee pot"));

function equalbrackets(str) {
  console.log(str.split("").reverse().join(""));
  return str.split("").reverse().join() == str.split("").join();
}
console.log(equalbrackets("(){}[]"));

// This question is asked by Amazon. Given two strings s and t, which represents a sequence of keystrokes, where # denotes a backspace, return whether or not the sequences produce the same result.

// Ex: Given the following strings...

// s = "ABC#", t = "CD##AB", return true
// s = "como#pur#ter", t = "computer", return true
// s = "cof#dim#ng", t = "code", return false

function backSpaceCompare(str1, str2) {
  console.log(str1, str2);
  return editString(str1) === editString(str2);
}

function editString(str) {
  let arr = [];
  for (let a of str) {
    if (a === "#") {
      arr.pop();
    } else {
      arr.push(a);
    }
  }
  console.log(arr);
  return arr.join("");
}
console.log(backSpaceCompare("ABC#", "CD##AB"));
console.log(backSpaceCompare("como#pur#ter", "computer"));
console.log(backSpaceCompare("cof#dim#ng", "code"));
console.log(backSpaceCompare("abc#d", "abd")); // true
console.log(backSpaceCompare("abc##", "a#")); // true
console.log(backSpaceCompare("a##c", "#a#c")); // true
console.log(backSpaceCompare("a#c", "b")); // false
console.log(backSpaceCompare("###", "####")); // true (both become empty)
console.log(backSpaceCompare("x#y#z#", "a#b#c#")); // true (both become empty)
console.log(backSpaceCompare("abcd##e#", "abf#d#e#")); // true
console.log(backSpaceCompare("##a##b", "###b")); // true
console.log(backSpaceCompare("abc###", "xyz###")); // true (both become empty)
console.log(backSpaceCompare("a###b", "b")); // true
console.log(backSpaceCompare("xyz#", "xy")); // true
console.log(backSpaceCompare("abc#d##c", "a#c")); // true
console.log(backSpaceCompare("aa#bb#cc#", "abc#")); // false
console.log(backSpaceCompare("abc#", "abcd#")); // true
console.log(backSpaceCompare("a##bc##d", "d")); // true
console.log(backSpaceCompare("abcd####", "wxyz####")); // true (both become empty)
console.log(backSpaceCompare("##abc#d##", "wxyz####")); // true
console.log(backSpaceCompare("a#b#c#d#", "####")); // true (both become empty)
console.log(backSpaceCompare("x#y##z#", "z##")); // true
console.log(backSpaceCompare("back##space", "backspace")); // true
console.log(backSpaceCompare("back###", "b#")); // true (both become empty)
console.log(backSpaceCompare("abc###", "xyz##")); // false (one is empty, one is "x")
